#include<log-manager/LogServerRequest.h>
#include<log-manager/LogServerConnection.h>

#include <util/ClockTimer.h>
#include <common/Utilities.h>

#include <LogServerStorage.h>
#include <boost/uuid/random_generator.hpp>
#include <ctime>
#include <util/concurrent_queue.h>

using namespace sf1r;
using namespace boost::uuids;


int main(){
/*
	typedef uint128_t uuid_t;    // docid type for SCDs auto generated by SF1R.
	typedef uint128_t md5_t;
	typedef md5_t  raw_docid_t;  // docid type for SCDs crawled by Bridge (Crawler).
	typedef std::vector<raw_docid_t> raw_docid_list_t;

	// DRUM <uuid, raw_docids>
	typedef izenelib::drum::Drum<
		uuid_t,
		raw_docid_list_t,
		std::string,
		izenelib::am::leveldb::TwoPartComparator,
		izenelib::am::leveldb::Table,
		DrumDispatcher
	> UuidDrumType;  
      	typedef boost::scoped_ptr<UuidDrumType> UuidDrumPtr;
	
	  typedef DrumDispatcher<
		uuid_t,
		raw_docid_list_t,
		std::string
	    > UuidDrumDispatcherType;

	  UuidDrumDispatcherType uuidDrumDispatcher;
    LogServerCfg::get()->parse("logserver.cfg");
    UuidDrumPtr drum;
    drum.reset(new UuidDrumType(
		    LogServerCfg::get()->getDrumName(LogServerCfg::UUID),
                    LogServerCfg::get()->getDrumNumBuckets(LogServerCfg::UUID),
                    LogServerCfg::get()->getDrumBucketBuffElemSize(LogServerCfg::UUID),
                    LogServerCfg::get()->getDrumBucketByteSize(LogServerCfg::UUID),
		    uuidDrumDispatcher
                    ));
    // Initialize SCD DB
	std::string scdDbName = LogServerCfg::get()->getStorageBaseDir() + "/scd_db";
	boost::filesystem::create_directories(scdDbName);

    std::size_t NUM = 0x10;
    boost::uuids::random_generator random_gen;

    for(int i = 0; i < 5; ++i){
	    for(std::size_t i = 0; i < NUM; i++){
		boost::uuids::uuid uuid = random_gen();
		std::vector<uint128_t> docidList(3);
		docidList.push_back(*reinterpret_cast<uint128_t *>(&uuid));
		docidList.push_back(*reinterpret_cast<uint128_t *>(&uuid));
		docidList.push_back(*reinterpret_cast<uint128_t *>(&uuid));
		drum->Update(*reinterpret_cast<uint128_t *>(&uuid), docidList);
		if (i%10000 == 0)
		{
		    std::cout<<"\r"<<std::left<<setw(16)<<i<<"\t"<<int(i*100.0/NUM)<<"%"<<std::flush;
		}
	    }
	    std::cout<<"\r"<<std::left<<setw(16)<<NUM<<"\t100%"<<std::endl;
	    drum->Synchronize();
	    time_t tm = std::time(NULL);
	    while(std::time(NULL) < tm + 20);
    }

    std::deque<int> queue;
    for(int i = 0; i < 5; ++i){
        for(int i = 0; i < 0x2000000; ++i){
            queue.push_back(i);
        }
        time_t tm = std::time(NULL);
        while(std::time(NULL) - tm  < 20);
        {
    //        std::vector<int>().swap(queue);
            queue.clear();
        }
        cout<<"clear"<<endl;
    }
    while(true);
*/
}
