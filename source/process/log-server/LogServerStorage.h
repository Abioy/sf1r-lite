#ifndef LOG_SERVER_STORAGE_H_
#define LOG_SERVER_STORAGE_H_

#include "LogServerCfg.h"
#include "DrumDispatcher.h"

#include <util/singleton.h>
#include <am/leveldb/Table.h>
#include <am/tokyo_cabinet/tc_hash.h>
#include <am/tokyo_cabinet/tc_fixdb.h>
#include <3rdparty/am/drum/drum.hpp>

#include <boost/shared_ptr.hpp>

namespace sf1r
{

class LogServerStorage
{
public:
    // DRUM <uuid_docid, raw_docids>
    typedef uint128_t uuid_docid_t;
    typedef uint128_t raw_docid_t;  // raw docids (md5) were generated by crawler
    typedef uuid_docid_t drum_key_t;
    typedef std::vector<raw_docid_t> drum_value_t;
    typedef std::string drum_aux_t;

    typedef DrumDispatcher<
                drum_key_t,
                drum_value_t,
                drum_aux_t
    > DrumDispatcherImpl;

    typedef izenelib::drum::Drum<
        drum_key_t,
        drum_value_t,
        drum_aux_t,
        izenelib::am::leveldb::TwoPartComparator,
        izenelib::am::leveldb::Table,
        DrumDispatcher
    > DrumType;
    typedef boost::scoped_ptr<DrumType> DrumPtr;

    // DB <raw_docid, uuid_docid>
    //typedef izenelib::am::tc_fixdb<raw_docid_t> KVDBType;
    typedef izenelib::am::tc_hash<raw_docid_t, drum_key_t> KVDBType;
    typedef boost::scoped_ptr<KVDBType> KVDBPtr;

public:
    static LogServerStorage* get()
    {
        return izenelib::util::Singleton<LogServerStorage>::get();
    }

    bool init()
    {
        // Initialize drum
        drum_.reset(
                new DrumType(
                    LogServerCfg::get()->getDrumName(),
                    LogServerCfg::get()->getDrumNumBuckets(),
                    LogServerCfg::get()->getDrumBucketBuffElemSize(),
                    LogServerCfg::get()->getDrumBucketByteSize(),
                    drumDispathcerImpl_
                ));

        if (!drum_)
        {
            std::cerr << "Failed to initialzie drum: " << LogServerCfg::get()->getDrumName() << std::endl;
            return false;
        }

        // Initialize <docid, uuid> DB
        docidDB_.reset(new KVDBType(LogServerCfg::get()->getDocidDBName()));
        if (!docidDB_ || !docidDB_->open())
        {
            std::cerr << "Failed to initialzie docid DB: " << LogServerCfg::get()->getDocidDBName() << std::endl;
            return false;
        }

        return true;
    }

    void close()
    {
        try
        {
            std::cout << "~LogServerStorage" << std::endl;
            if (drum_)
            {
                boost::unique_lock<boost::mutex> lock(drum_mutex_, boost::defer_lock);
                if (lock.try_lock())
                {
                    drum_.reset();
                }
                else
                {
                    std::cout << "Drum is still working... " << std::endl;
                    return;
                }
            }

            if (docidDB_)
            {
                boost::unique_lock<boost::mutex> lock(docid_db_mutex_, boost::defer_lock);
                if (lock.try_lock())
                {
                    docidDB_->flush();
                    docidDB_->close();
                    docidDB_.reset();
                }
                else
                {
                    std::cout << "DocidDB is still working... " << std::endl;
                    return;
                }
            }
        }
        catch (const std::exception& e)
        {
            std::cout << "LogServerStorage close: " << e.what() << std::endl;
        }
    }

    DrumDispatcherImpl& drumDispatcher()
    {
        return drumDispathcerImpl_;
    }

    /// @brief lock drumMutex before operation on Drum
    DrumPtr& drum()
    {
        return drum_;
    }

    /// @brief lock docidDBMutex before operation on DocidDB
    KVDBPtr& docidDB()
    {
        return docidDB_;
    }

    boost::mutex& drumMutex()
    {
        return drum_mutex_;
    }

    boost::mutex& docidDBMutex()
    {
        return docid_db_mutex_;
    }

private:
    DrumDispatcherImpl drumDispathcerImpl_;
    DrumPtr drum_;

    KVDBPtr docidDB_;

    boost::mutex drum_mutex_;
    boost::mutex docid_db_mutex_;
};

}

#endif /* LOG_SERVER_STORAGE_H_ */
