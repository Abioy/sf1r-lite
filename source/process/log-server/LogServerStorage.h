#ifndef LOG_SERVER_STORAGE_H_
#define LOG_SERVER_STORAGE_H_

#include "LogServerCfg.h"
#include "DrumDispatcher.h"

#include <util/singleton.h>
#include <am/leveldb/Table.h>
#include <am/tokyo_cabinet/tc_hash.h>
#include <am/tokyo_cabinet/tc_fixdb.h>
#include <3rdparty/am/drum/drum.hpp>

#include <boost/shared_ptr.hpp>
#include <boost/filesystem.hpp>
#include <boost/unordered_map.hpp>

namespace sf1r
{

#define USE_TC_HASH

class LogServerStorage
{
public:
    typedef uint128_t uuid_t;    // docid type for SCDs auto generated by SF1R.
    typedef uint128_t md5_t;
    typedef md5_t  raw_docid_t;  // docid type for SCDs crawled by Bridge (Crawler).
    typedef std::vector<raw_docid_t> raw_docid_list_t;

    // DRUM <uuid, raw_docids>
    typedef izenelib::drum::Drum<
    uuid_t,
    raw_docid_list_t,
    std::string,
    izenelib::am::leveldb::TwoPartComparator,
    izenelib::am::leveldb::Table,
    DrumDispatcher
    > UuidDrumType;
    typedef boost::scoped_ptr<UuidDrumType> UuidDrumPtr;

    typedef DrumDispatcher<
    uuid_t,
    raw_docid_list_t,
    std::string
    > UuidDrumDispatcherType;

    // DRUM <raw_docid, uuid>
    typedef izenelib::drum::Drum<
    raw_docid_t,
    uuid_t,
    std::string,
    izenelib::am::leveldb::TwoPartComparator,
    izenelib::am::leveldb::Table,
    DrumDispatcher
    > DocidDrumType;
    typedef boost::scoped_ptr<DocidDrumType> DocidDrumPtr;

    typedef DrumDispatcher<
    raw_docid_t,
    uuid_t,
    std::string
    > DocidDrumDispatcherType;

    // KV DB
#ifdef USE_TC_HASH
    typedef izenelib::am::tc_hash<uuid_t, std::string> ScdDbType;
#else
    typedef izenelib::am::leveldb::Table<uuid_t, std::string> ScdDbType;
#endif
    typedef boost::scoped_ptr<ScdDbType> ScdDbPtr;

    struct ScdStorage
    {
        ScdDbPtr scdDb_;
        boost::mutex mutex_;
        bool isReIndexed_;      // whether scd in db has been requested for reindexing
        std::ofstream scdFile_; // for scd which come after reindex
        std::string scdFileName_;
    };

public:
    static LogServerStorage* get()
    {
        return izenelib::util::Singleton<LogServerStorage>::get();
    }

    bool init()
    {
        // Initialize DRUM <uuid, raw_docids>
        uuidDrum_.reset(
            new UuidDrumType(
                LogServerCfg::get()->getDrumName(LogServerCfg::UUID),
                LogServerCfg::get()->getDrumNumBuckets(LogServerCfg::UUID),
                LogServerCfg::get()->getDrumBucketBuffElemSize(LogServerCfg::UUID),
                LogServerCfg::get()->getDrumBucketByteSize(LogServerCfg::UUID),
                uuidDrumDispathcer_
            ));

        if (!uuidDrum_)
        {
            std::cerr << "Failed to initialzie drum: "
                      << LogServerCfg::get()->getDrumName(LogServerCfg::UUID) << std::endl;
            return false;
        }

        // Initialize DRUM <raw_docid, uuid>
        docidDrum_.reset(
            new DocidDrumType(
                LogServerCfg::get()->getDrumName(LogServerCfg::DOCID),
                LogServerCfg::get()->getDrumNumBuckets(LogServerCfg::DOCID),
                LogServerCfg::get()->getDrumBucketBuffElemSize(LogServerCfg::DOCID),
                LogServerCfg::get()->getDrumBucketByteSize(LogServerCfg::DOCID),
                docidDrumDispathcer_
            ));

        if (!docidDrum_)
        {
            std::cerr << "Failed to initialzie drum: "
                      << LogServerCfg::get()->getDrumName(LogServerCfg::DOCID) << std::endl;
            return false;
        }

        // Initialize SCD DB
        std::string scdDbName = LogServerCfg::get()->getStorageBaseDir() + "/scd_db";
        boost::filesystem::create_directories(scdDbName);

//        scdDb_.reset(new ScdDbType(scdDbName));
//        if (!scdDb_ || !scdDb_->open())
//        {
//            std::cerr << "Failed to initialzie scd DB (check DbType?) : " << scdDbName << std::endl;
//            return false;
//        }

        return true;
    }

    void close()
    {
        try
        {
            std::cout << "~LogServerStorage" << std::endl;
            if (uuidDrum_)
            {
                boost::unique_lock<boost::mutex> lock(uuidDrumMutex_, boost::defer_lock);
                if (lock.try_lock())
                {
                    uuidDrum_.reset();
                }
                else
                {
                    std::cout << "Drum is still working... " << std::endl;
                    return;
                }
            }

            if (docidDrum_)
            {
                boost::unique_lock<boost::mutex> lock(docidDrumMutex_, boost::defer_lock);
                if (lock.try_lock())
                {
                    docidDrum_.reset();
                }
                else
                {
                    std::cout << "Drum is still working... " << std::endl;
                    return;
                }
            }

            // close scd dbs
            CollectionScdDbMapType::iterator it;
            for (it = collectionScdDbMap_.begin(); it != collectionScdDbMap_.end(); it++)
            {
                if (it->second)
                {
                    boost::unique_lock<boost::mutex> lock(it->second->mutex_);
                    it->second->scdDb_->flush();
                    it->second->scdDb_->close();
                }
            }

//            if (scdDb_)
//            {
//                boost::unique_lock<boost::mutex> lock(scdDbMutex_, boost::defer_lock);
//                if (lock.try_lock())
//                {
//                    scdDb_->flush();
//                    scdDb_->close();
//                    scdDb_.reset();
//                }
//                else
//                {
//                    std::cout << "scdDb_ is still working... " << std::endl;
//                    return;
//                }
//            }
        }
        catch (const std::exception& e)
        {
            std::cout << "LogServerStorage close: " << e.what() << std::endl;
        }
    }

    /// @brief lock uuidDrumMutex before operation on Drum
    UuidDrumPtr& uuidDrum()
    {
        return uuidDrum_;
    }

    boost::mutex& uuidDrumMutex()
    {
        return uuidDrumMutex_;
    }

    UuidDrumDispatcherType& uuidDrumDispatcher()
    {
        return uuidDrumDispathcer_;
    }

    /// @brief lock docidDrumMutex before operation on Drum
    DocidDrumPtr& docidDrum()
    {
        return docidDrum_;
    }

    boost::mutex& docidDrumMutex()
    {
        return docidDrumMutex_;
    }

    DocidDrumDispatcherType& docidDrumDispatcher()
    {
        return docidDrumDispathcer_;
    }

    /// @brief lock scdDbMutex before operation on scdDB
//    ScdDbPtr& scdDb()
//    {
//        return scdDb_;
//    }
//
//    boost::mutex& scdDbMutex()
//    {
//        return scdDbMutex_;
//    }

    bool checkScdDb(const std::string& collection)
    {
        if (collectionScdDbMap_.find(collection) == collectionScdDbMap_.end())
        {
            return initScdDb(collection);
        }

        return true;
    }

    boost::shared_ptr<ScdStorage>& scdStorage(const std::string& collection)
    {
        if (collectionScdDbMap_.find(collection) == collectionScdDbMap_.end())
        {
            initScdDb(collection);
        }

        return collectionScdDbMap_[collection];
    }

//    boost::mutex& scdDbMutex(const std::string& collection)
//    {
//        if (collectionScdDbMap_.find(collection) == collectionScdDbMap_.end())
//        {
//            initScdDb(collection);
//        }
//
//        return collectionScdDbMap_[collection]->mutex_;
//    }

private:
    /// init DB for SCD
    bool initScdDb(const std::string& collection)
    {
        std::string scdDbName = LogServerCfg::get()->getStorageBaseDir() + "/scd_db/" + collection;
        std::cout << "initScdDb " << scdDbName << std::endl;

        boost::shared_ptr<ScdStorage> store(new ScdStorage);
        store->scdDb_.reset(new ScdDbType(scdDbName));
        store->isReIndexed_ = false;

        if (!store->scdDb_ || !store->scdDb_->open())
        {
            std::cerr << "Failed to initialzie scd DB (check DbType?) : " << scdDbName << std::endl;
            return false;
        }

        store->scdFileName_ = LogServerCfg::get()->getStorageBaseDir() + "/scd_db/" + collection + ".scd";
        std::ifstream testfile(store->scdFileName_.c_str());
        if (!testfile.good())
        {
            testfile.close();
            store->scdFile_.open(store->scdFileName_.c_str()); // create
        }
        else
        {
            testfile.close();
            store->scdFile_.open(store->scdFileName_.c_str(), fstream::out|fstream::app);
        }

        collectionScdDbMap_[collection] = store;
        return true;
    }

private:
    UuidDrumDispatcherType uuidDrumDispathcer_;
    UuidDrumPtr uuidDrum_;
    boost::mutex uuidDrumMutex_;

    DocidDrumDispatcherType docidDrumDispathcer_;
    DocidDrumPtr docidDrum_;
    boost::mutex docidDrumMutex_;

    // Used to store SCD of user submitted comments currently.
//    ScdDbPtr scdDb_;
//    boost::mutex scdDbMutex_;

    typedef boost::unordered_map<std::string, boost::shared_ptr<ScdStorage> > CollectionScdDbMapType;
    CollectionScdDbMapType collectionScdDbMap_;
};

}

#endif /* LOG_SERVER_STORAGE_H_ */
