#ifndef LOG_SERVER_STORAGE_H_
#define LOG_SERVER_STORAGE_H_

#include "LogServerCfg.h"
#include "DrumDispatcher.h"

#include <util/singleton.h>
#include <am/leveldb/Table.h>
#include <am/tokyo_cabinet/tc_hash.h>
#include <am/tokyo_cabinet/tc_fixdb.h>
#include <3rdparty/am/drum/drum.hpp>

#include <boost/shared_ptr.hpp>

namespace sf1r
{

class LogServerStorage
{
public:
    typedef uint128_t uuid_t;    // docid type for SCDs auto generated by SF1R.
    typedef uint128_t md5_t;
    typedef md5_t  raw_docid_t;  // docid type for SCDs crawled by Bridge (Crawler).
    typedef std::vector<raw_docid_t> raw_docid_list_t;

    // DRUM <uuid, raw_docids>
    typedef izenelib::drum::Drum<
        uuid_t,
        raw_docid_list_t,
        std::string,
        izenelib::am::leveldb::TwoPartComparator,
        izenelib::am::leveldb::Table,
        DrumDispatcher
    > UuidDrumType;
    typedef boost::scoped_ptr<UuidDrumType> UuidDrumPtr;

    typedef DrumDispatcher<
        uuid_t,
        raw_docid_list_t,
        std::string
    > UuidDrumDispatcherType;

    // DB <raw_docid, uuid>
    //typedef izenelib::am::tc_fixdb<raw_docid_t> KVDBType;
    typedef izenelib::am::tc_hash<raw_docid_t, uuid_t> KVDBType;
    typedef boost::scoped_ptr<KVDBType> KVDBPtr;

    // DRUM <raw_docid, uuid>
    typedef izenelib::drum::Drum<
        raw_docid_t,
        uuid_t,
        std::string,
        izenelib::am::leveldb::TwoPartComparator,
        izenelib::am::leveldb::Table,
        DrumDispatcher
    > DocidDrumType;
    typedef boost::scoped_ptr<DocidDrumType> DocidDrumPtr;

    typedef DrumDispatcher<
        raw_docid_t,
        uuid_t,
        std::string
    > DocidDrumDispatcherType;

public:
    static LogServerStorage* get()
    {
        return izenelib::util::Singleton<LogServerStorage>::get();
    }

    bool init()
    {
        // Initialize DRUM <uuid, raw_docids>
        uuidDrum_.reset(
                new UuidDrumType(
                    LogServerCfg::get()->getDrumName(LogServerCfg::UUID),
                    LogServerCfg::get()->getDrumNumBuckets(LogServerCfg::UUID),
                    LogServerCfg::get()->getDrumBucketBuffElemSize(LogServerCfg::UUID),
                    LogServerCfg::get()->getDrumBucketByteSize(LogServerCfg::UUID),
                    uuidDrumDispathcer_
                ));

        if (!uuidDrum_)
        {
            std::cerr << "Failed to initialzie drum: "
                      << LogServerCfg::get()->getDrumName(LogServerCfg::UUID) << std::endl;
            return false;
        }

        // Initialize DRUM <raw_docid, uuid>
        docidDrum_.reset(
                new DocidDrumType(
                    LogServerCfg::get()->getDrumName(LogServerCfg::DOCID),
                    LogServerCfg::get()->getDrumNumBuckets(LogServerCfg::DOCID),
                    LogServerCfg::get()->getDrumBucketBuffElemSize(LogServerCfg::DOCID),
                    LogServerCfg::get()->getDrumBucketByteSize(LogServerCfg::DOCID),
                    docidDrumDispathcer_
                ));

        if (!docidDrum_)
        {
            std::cerr << "Failed to initialzie drum: "
                      << LogServerCfg::get()->getDrumName(LogServerCfg::DOCID) << std::endl;
            return false;
        }

        // Initialize <docid, uuid> DB
        docidDB_.reset(new KVDBType(LogServerCfg::get()->getDocidDBName()));
        if (!docidDB_ || !docidDB_->open())
        {
            std::cerr << "Failed to initialzie docid DB: " << LogServerCfg::get()->getDocidDBName() << std::endl;
            return false;
        }

        return true;
    }

    void close()
    {
        try
        {
            std::cout << "~LogServerStorage" << std::endl;
            if (uuidDrum_)
            {
                boost::unique_lock<boost::mutex> lock(uuidDrumMutex_, boost::defer_lock);
                if (lock.try_lock())
                {
                    uuidDrum_.reset();
                }
                else
                {
                    std::cout << "Drum is still working... " << std::endl;
                    return;
                }
            }

            if (docidDrum_)
            {
                boost::unique_lock<boost::mutex> lock(docidDrumMutex_, boost::defer_lock);
                if (lock.try_lock())
                {
                    docidDrum_.reset();
                }
                else
                {
                    std::cout << "Drum is still working... " << std::endl;
                    return;
                }
            }

            if (docidDB_)
            {
                boost::unique_lock<boost::mutex> lock(docid_db_mutex_, boost::defer_lock);
                if (lock.try_lock())
                {
                    docidDB_->flush();
                    docidDB_->close();
                    docidDB_.reset();
                }
                else
                {
                    std::cout << "DocidDB is still working... " << std::endl;
                    return;
                }
            }
        }
        catch (const std::exception& e)
        {
            std::cout << "LogServerStorage close: " << e.what() << std::endl;
        }
    }

    /// @brief lock uuidDrumMutex before operation on Drum
    UuidDrumPtr& uuidDrum()
    {
        return uuidDrum_;
    }

    boost::mutex& uuidDrumMutex()
    {
        return uuidDrumMutex_;
    }

    UuidDrumDispatcherType& uuidDrumDispatcher()
    {
        return uuidDrumDispathcer_;
    }

    /// @brief lock docidDrumMutex before operation on Drum
    DocidDrumPtr& docidDrum()
    {
        return docidDrum_;
    }

    boost::mutex& docidDrumMutex()
    {
        return docidDrumMutex_;
    }

    DocidDrumDispatcherType& docidDrumDispatcher()
    {
        return docidDrumDispathcer_;
    }

    /// @brief lock docidDBMutex before operation on DocidDB
    KVDBPtr& docidDB()
    {
        return docidDB_;
    }

    boost::mutex& docidDBMutex()
    {
        return docid_db_mutex_;
    }

private:
    UuidDrumDispatcherType uuidDrumDispathcer_;
    UuidDrumPtr uuidDrum_;
    boost::mutex uuidDrumMutex_;

    DocidDrumDispatcherType docidDrumDispathcer_;
    DocidDrumPtr docidDrum_;
    boost::mutex docidDrumMutex_;

    // TODO remove docidDB
    KVDBPtr docidDB_;
    boost::mutex docid_db_mutex_;
};

}

#endif /* LOG_SERVER_STORAGE_H_ */
